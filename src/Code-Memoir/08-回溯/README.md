#  回溯
> 暴力穷举算法


---

### 回溯算法理论

回溯和递归的区别： 回溯是递归的副产品，有递归就有回溯

回溯本质：穷举所有可能，列出想要的答案。 可以➕剪枝的操作



回溯解决的问题：

- 组合问题：N个数按一定规则找出K个数的集合
- 切割问题：字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题： N皇后、数独

> 排列有序，组合无序



**回溯可抽象为树形结构（n叉树）**

- 如果对于一个数字取或者不取，则回溯可以抽象为二叉树

because - 回溯是在集合（数组）中递归查找子集， 集合大小为树的宽度，递归深度为树的深度



**回溯三部曲（类似于递归模版）：**

1. 确定回溯函数backtracking模版的返回值和参数

   - 回溯返回值一般为void，即 直接 return
   - 回溯参数一般不容易一次性就确定，写逻辑过程中可确定

2. 回溯终止条件

   - ```
     if (终止条件) {
         存放结果;
         return;
     }
     ```

3. 回溯搜索的遍历过程

   - 回溯一般是在集合中递归搜索，集合大小为树的宽度（横向），递归深度为树的深度（纵向）

   - ```
     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
       处理节点
       backtracking(路径，选择列表) // 递归
       回溯，撤销处理结果
     }
     ```

   - 其中：for循环是横向遍历，backtracking递归是纵向遍历

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { // 横向遍历
        处理节点（操作）;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```



---

### 回溯与深度优先搜索关系



回溯是深度优先搜素的子集，是一种带有回溯的深度优先搜索



回溯 = 搜索 + 回溯 ， 搜素部分可以用深度优先搜索方法



回溯要做回溯信息的一些处理，单纯的回退节点不算回溯，只是一种深度优先搜索



回溯 = 回退

---

### 二叉树深度优先搜索基础模版



应用场景：

- 二叉树有关
- 需要从根节点遍历到末尾叶子节点



常见题型： （最大、最小、某种要求）的深度、路径、节点和 ....

```js
function dfsTemplate(root) {
    //存储最终结果
    let res;
    //初始化当前结果
    let start;
    //构造递归函数dfs,通常参数为当前节点和当前结果
    let dfs = function (node, currentResult) {
        //终止条件返回判断
        if (node == null) {
            return;
        }
        //更新当前结果currentResult

        //若到达末尾叶子结点，进行最优结果更新
        if (node.left == null && node.right == null) {
            //update res
        }
        //左右子树递归
        dfs(node.left, currentResult);
        dfs(node.right, currentResult);
    }
    dfs(root, start);
    return res;
}


```

