# 二叉树

>二叉树递归的重要思想：
>
>- 如果抽出一个二叉树节点，这个单独的节点它需要做什么，需要在什么时候（前、中、后位置）做？
>- 其余的节点会通过递归的方式来做
>
>
>
>前序位置、中序位置、后序位置 （这三个概念都是以时间概念为基准，三个特殊的时间段）
>
>- 前序位置：刚进入一个节点元素的时候
>- 后序位置：即将离开一个节点元素的时候
>- 中序位置：（中序位置仅针对二叉树）：是该二叉树节点左子树遍历完，即将进入右子树的时间段执行
>
>
>
>前序、后序之间的特殊性
>
>- 前序序列只能从函数参数中获取父节点传递过来的数据
>- 后序序列不仅可以获得函数参数，还可以获取子树通过函数返回值返回回来的数据
>  - 题目和子树有关，就大概率要在后序位置写代码了
>
>
>
>二叉树的问题：
>
>- 所有二叉树的问题都是在前中后序位置注入代码逻辑，去达到目的，仅仅需要思考每一个节点需要做什么
>- 遍历问题（回溯算法的核心）===> 遍历二叉树得到答案
>- 分解问题（动态规划算法的核心） ===> 子问题的答案推导原问题的答案
>  - 分解问题最重要的是定义函数的意义
>- 重要：二叉树题目，先思考能不能通过遍历来解决，如果不能是否可以定义一个递归函数，通过子问题（子树）的答案来推导出原问题的答案？如果需要涉及到子树的信息，可以考虑使用后序遍历





遍历二叉树所有节点模版：

```js
function traversal(node) {
	if (!root) return

	// 前序位置
	traversal(node.left)
	// 中序位置
	traversal(node.right)
	// 后序位置
}

// 递归遍历数组
function traversal(arr, i) {
  if (i === arr.length) return

  // 前序位置
  traversal(arr, i + 1)
  // 后序位置
}
```





前序遍历用分解的方法来做：

- 一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果









---

### 二叉树题目分类

- 二叉树的遍历方式
- 二叉树的属性
- 二叉树的修改与构造
- 求二叉搜索树的属性



### 二叉树的遍历

- 深度优先遍历（先往深走，遇到叶子节点再往回走）
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历（一层一层去遍历）
  - 层次遍历（迭代法）



>     栈是递归的一种实现结构，前中后序遍历逻辑可以借助栈使用非递归的方式来实现
>
>     层次遍历可以用队列来模拟



---



### 二叉树的递归遍历

>二叉树的递归解法的思路：
>
>- **遍历**二叉树得出的答案（回溯） traversal函数+外部变量
>- **分解问题**得出的答案（动态规划）

**递归：重复利用函数本身来实现功能**



**递归函数写法三个要素：**

- 确定递归函数的参数和返回值
  - 递归参数是递归过程中需要处理的参数（二叉树中多为”当前节点 + 当前结果参数“）
  - 返回值是递归函数返回的类型
- 确定终止条件
  - 操作系统用一个栈保存递归的信息，如果没有终止条件或终止条件不对，则会发生栈溢出
  - 二叉树的终止条件：遇到了空节点
- 确定单层递归的逻辑
  - 实现递归的过程



> 二叉树的递归参数：二叉树的头节点的指针 + 数组存放遍历的结果（JS有闭包，可以把数组定义在外部函数）



**递归的实现：**

递归的每一次调用都会把函数的局部参数、参数值、返回地址等压入调用栈



二叉树递归遍历模版

```js
function helper(当前节点) {
  终止条件判断(遍历到尽头直接return)
  节点记录
  对左节点调用helper
  对右节点调用helper
}
对根节点调用helper
返回结果

```









---

### 二叉树的层次遍历



二叉树的层次遍历

需要用到队列

```js
var levelOrder = function(root) {
  let queue = []
  if (root !== null) queue.push(root)

  while (queue.length !== 0) {
    let node = queue.shift()
    console.log(node.val) // 执行相关操作
    if (node.left) {
      queue.push(node.left)
    }
    if (node.right) {
      queue.push(node.right)
    }
  }

};
```

>  对于出对的元素，如果该出队元素有左右节点，则需要依次在队列中添加左右节点



**对于层序遍历还要考虑对于同一层的节点元素的操作**

```js
var levelOrder = function(root) {
  if (root === []) return []

  let queue = []
  let res = []
  if (root !== null) queue.push(root)

  while (queue.length !== 0) {
    // 记录当前层级保存的节点数
    let levelCount = queue.length
    // 存放每一层的节点
    let curLevel = []
    for (let i = 0; i < levelCount; i++) {
      let node = queue.shift()
      // 此处往下的片段是对于操作元素的片段，其余都为模版
      curLevel.push(node.val) // 把当前节点的值存入临时数组
      if (node.left !== null) {
        queue.push(node.left)
      }
      if (node.right) {
        queue.push(node.right)
      }
    }
    res.push(curLevel)
  }
  return res
};
```











